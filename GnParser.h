

// This file was automatically generated by Coco/R; don't modify it.
#if !defined(Gn_COCO_PARSER_H__)
#define Gn_COCO_PARSER_H__

#include <QStack>
#include <GnTools/GnSynTree.h>


#define PARSER_NS Gn
#include <GnTools/GnLexer.h>

namespace Gn {



class Parser {
private:
	enum {
		_EOF=0,
		_T_Literals_=1,
		_T_Bang=2,
		_T_BangEq=3,
		_T_Hash=4,
		_T_2Amp=5,
		_T_Lpar=6,
		_T_Rpar=7,
		_T_Plus=8,
		_T_PlusEq=9,
		_T_Comma=10,
		_T_Minus=11,
		_T_MinusEq=12,
		_T_Dot=13,
		_T_Lt=14,
		_T_Leq=15,
		_T_Eq=16,
		_T_2Eq=17,
		_T_Gt=18,
		_T_Geq=19,
		_T_Lbrack=20,
		_T_Rbrack=21,
		_T_Lbrace=22,
		_T_2Bar=23,
		_T_Rbrace=24,
		_T_Keywords_=25,
		_T_else=26,
		_T_false=27,
		_T_if=28,
		_T_true=29,
		_T_Specials_=30,
		_T_identifier=31,
		_T_integer=32,
		_T_string=33,
		_T_Comment=34,
		_T_Eof=35,
		_T_MaxToken_=36
	};
	int maxT;

	int errDist;
	int minErrDist;

	void SynErr(int n, const char* ctx = 0);
	void Get();
	void Expect(int n, const char* ctx = 0);
	bool StartOf(int s);
	void ExpectWeak(int n, int follow);
	bool WeakSeparator(int n, int syFol, int repFol);
    void SynErr(const QString& sourcePath, int line, int col, int n, PARSER_NS::Errors* err, const char* ctx, const QString& = QString() );

public:
	PARSER_NS::Lexer *scanner;
	PARSER_NS::Errors  *errors;

	PARSER_NS::Token d_cur;
	PARSER_NS::Token d_next;
	QList<PARSER_NS::Token> d_comments;
	struct TokDummy
	{
		int kind;
	};
	TokDummy d_dummy;
	TokDummy *la;			// lookahead token
	
	int peek( quint8 la = 1 );

    void RunParser()
    {
        d_stack.push(&d_root);
        Parse();
        d_stack.pop();
    }
    
    void ParsePrimaryExpr();
    
Gn::SynTree d_root;
	QStack<Gn::SynTree*> d_stack;
	void addTerminal() {
		if( d_cur.d_type != Gn::Tok_Comma ){
			Gn::SynTree* n = new Gn::SynTree( d_cur ); d_stack.top()->d_children.append(n);
		}
	}



	Parser(PARSER_NS::Lexer *scanner,PARSER_NS::Errors*);
	~Parser();
	void SemErr(const char* msg);

	void File();
	void StatementList();
	void Statement();
	void Call();
	void Assignment();
	void Condition();
	void LValue();
	void Expr();
	void AssignOp();
	void ExprList();
	void Block();
	void ArrayAccess();
	void ScopeAccess();
	void UnaryExpr();
	void Expr_nlr_();
	void BinaryOp();
	void PrimaryExpr();
	void UnaryOp();
	void signed_();
	void Scope_();
	void List_();

	void Parse();

}; // end Parser

} // namespace


#endif

